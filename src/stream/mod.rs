//! Streams
//!
//! This module defines functions to combine `Stream`s with Rayon.

use futures::StreamExt;

mod rayon_map;
pub use rayon_map::RayonMap;

impl<T> RayonStreamExt for T where T: StreamExt + ?Sized {}

/// An extension trait for `Stream`s that provides a variety of convenient
/// combinator functions to interact with Rayon.
pub trait RayonStreamExt: StreamExt {
    /// Applies `map_op` to each item of this stream, producing a new
    /// stream with the results.
    /// The `map_op` function is run on Rayon's global thread pool and can be
    /// blocking or CPU intensive.
    ///
    /// # Examples
    /// ```
    /// # futures::executor::block_on(async {
    /// use futures::stream::{self, StreamExt};
    /// use futures::join;
    /// use async_rayon::stream::RayonStreamExt;
    ///
    /// let mut stream = stream::iter(1..=3).rayon_map(|x| {
    ///     // Make sure that the closure is run on a Rayon worker thread
    ///     assert!(rayon::current_thread_index().is_some());
    ///     x+3
    /// });
    ///
    /// assert_eq!(stream.next().await, Some(Ok(4)));
    /// assert_eq!(stream.next().await, Some(Ok(5)));
    /// assert_eq!(stream.next().await, Some(Ok(6)));
    /// assert_eq!(stream.next().await, None);
    /// # });
    /// ```
    ///
    /// You can safely cancel the futures generated by the stream's `next()`
    /// method. ```
    /// # let rt = tokio::runtime::Builder::new_current_thread()
    /// #                                   .enable_time()
    /// #                                   .build()
    /// #                                   .unwrap();
    /// # rt.block_on(async {
    /// use futures::stream::{self, StreamExt};
    /// use async_rayon::stream::RayonStreamExt;
    /// use std::time::Duration;
    ///
    /// let mut stream = stream::iter(1..=3).rayon_map(|x| {
    ///     // Simulate a CPU-intensive/blocking workload
    ///     std::thread::sleep(std::time::Duration::from_millis(200));
    ///     x+3
    /// });
    /// assert_eq!(stream.next().await, Some(Ok(4)));
    /// assert!(tokio::time::timeout(Duration::from_millis(50),
    ///                                         stream.next()).await.is_err());
    /// assert_eq!(stream.next().await, Some(Ok(5)));
    ///
    /// # });
    /// ```

    fn rayon_map<F, T>(self, map_op: F) -> RayonMap<Self, F, T>
    where
        Self: Sized,
        Self::Item: Send + 'static,
        F: Fn(Self::Item) -> T + Send + Sync + 'static,
        T: Send + 'static,
    {
        RayonMap::new(self, map_op)
    }
}
